using CommonLib.Utils;
using Newtonsoft.Json;
using ProtoBuf;
using System;
using System.Collections;
using Vintagestory.API.Common;

namespace StoneQuarry
{
    [JsonObject]
    [ProtoContract]
    public class RockData : IEnumerable, ICloneable, IComparable<RockData>
    {
        public static AssetLocation UndefinedRock => new("");
        public static readonly string[] types =
        {
            "rock",
            "stone",
            "rockpolished",
            "stonebrick",
            "gravel",
            "sand"
        };

        [ProtoMember(1)] public AssetLocation Rock;
        [ProtoMember(2)] public AssetLocation? Stone;
        [ProtoMember(3)] public AssetLocation? RockPolished;
        [ProtoMember(4)] public AssetLocation? StoneBrick;
        [ProtoMember(5)] public AssetLocation? Gravel;
        [ProtoMember(6)] public AssetLocation? Sand;

        public RockData()
        {
            Rock = UndefinedRock;
        }

        public AssetLocation? this[string type]
        {
            get => type switch
            {
                "rock" => Rock,
                "stone" => Stone,
                "rockpolished" => RockPolished,
                "stonebrick" => StoneBrick,
                "gravel" => Gravel,
                "sand" => Sand,
                _ => null
            };

            set
            {
                switch (type)
                {
                    case "rock": Rock = value ?? UndefinedRock; break;
                    case "stone": Stone = value; break;
                    case "rockpolished": RockPolished = value; break;
                    case "stonebrick": StoneBrick = value; break;
                    case "gravel": Gravel = value; break;
                    case "sand": Sand = value; break;
                }
            }
        }

        public string? this[AssetLocation code]
        {
            get
            {
                if (code.Equals(Rock)) return "rock";
                if (code.Equals(Stone)) return "stone";
                if (code.Equals(RockPolished)) return "rockpolished";
                if (code.Equals(StoneBrick)) return "stonebrick";
                if (code.Equals(Gravel)) return "gravel";
                if (code.Equals(Sand)) return "sand";

                return null;
            }
        }

        public void SetWildcardValue(string wildcardValue, ICoreAPI api)
        {
            for (int i = 0; i < types.Length; i++)
            {
                string type = types[i];
                AssetLocation? code = this[type];
                if (code != null)
                {
                    code.Path = code.Path.Replace("*", wildcardValue);
                    if (api.World.GetCollectibleObject(code) == null)
                    {
                        Core.ModLogger.Debug("Removed non-existent {0} code {1} generated by the wildcard resolver", type, code);
                        this[type] = null;
                    }
                }
            }
        }

        public object Clone()
        {
            return new RockData()
            {
                Rock = Rock.Clone(),
                Stone = Stone?.Clone(),
                RockPolished = RockPolished?.Clone(),
                StoneBrick = StoneBrick?.Clone(),
                Gravel = Gravel?.Clone(),
                Sand = Sand?.Clone(),
            };
        }

        public IEnumerator GetEnumerator()
        {
            foreach (string type in types)
            {
                yield return this[type];
            }
        }

        public int CompareTo(RockData other)
        {
            return Rock.CompareTo(other.Rock);
        }
    }
}
